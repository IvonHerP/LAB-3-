//Ivon Hernandez
//231111
//lab 3 
/*
//***********************************PARTE 1****************************************************
#include <Arduino.h>
#include <stdint.h>

volatile int contador = 0;

// Pines solicitados:
const int leds[4] = {32, 33, 25, 14};
const int botonInc = 27;
const int botonDec = 26;

volatile unsigned long lastPressInc = 0;
volatile unsigned long lastPressDec = 0;

void mostrar(int valor);

void IRAM_ATTR incrementar() {
  unsigned long tiempo = millis();
  if (tiempo - lastPressInc > 200) {
    contador++;
    if (contador > 15) contador = 0;
    lastPressInc = tiempo;
  }
}

void IRAM_ATTR decrementar() {
  unsigned long tiempo = millis();
  if (tiempo - lastPressDec > 200) {
    contador--;
    if (contador < 0) contador = 15;
    lastPressDec = tiempo;
  }
}

void setup() {
  Serial.begin(115200);

  for (int i = 0; i < 4; i++) {
    pinMode(leds[i], OUTPUT);
  }

  pinMode(botonInc, INPUT_PULLUP);
  pinMode(botonDec, INPUT_PULLUP);

  attachInterrupt(digitalPinToInterrupt(botonInc), incrementar, FALLING);
  attachInterrupt(digitalPinToInterrupt(botonDec), decrementar, FALLING);
}

void loop() {
  mostrar(contador);
}

void mostrar(int valor) {
  for (int i = 0; i < 4; i++) {
    bool bitestado = bitRead(valor, i);
    digitalWrite(leds[i], bitestado);
  }
}

//***************************PARTE 2**************************************
#include <Arduino.h>
#include <stdint.h>
const int ledsAuto[4] = {12, 13, 15, 2};  // Pines para LEDs

hw_timer_t * timer = NULL;
volatile uint8_t contador = 0;

portMUX_TYPE timerMux = portMUX_INITIALIZER_UNLOCKED;

void IRAM_ATTR onTimer() {
  portENTER_CRITICAL_ISR(&timerMux);
  contador++;
  if (contador > 15) contador = 0;
  portEXIT_CRITICAL_ISR(&timerMux);

  for (int i = 0; i < 4; i++) {
    digitalWrite(ledsAuto[i], (contador >> i) & 0x01);
  }
}

void setup() {
  for (int i = 0; i < 4; i++) {
    pinMode(ledsAuto[i], OUTPUT);
    digitalWrite(ledsAuto[i], LOW);
  }

  timer = timerBegin(0, 80, true); // Prescaler 80 -> 1 tick = 1 us
  timerAttachInterrupt(timer, &onTimer, true);
  timerAlarmWrite(timer, 250000, true); // 250 ms
  timerAlarmEnable(timer);
}

void loop() {
  // Nada aquí
}

#include <Arduino.h>
#include <stdint.h>

// Pines LEDs contador manual
const int ledsManual[4] = {32, 33, 25, 14};
// Pines LEDs contador automático
const int ledsAuto[4] = {12, 13, 5, 2};
// Pin LED indicador
const int LED_INDICADOR = 4;

// Pines botones
const int botonInc = 27;
const int botonDec = 26;

volatile int contadorManual = 0;
volatile int contadorAutomatico = 0;
volatile bool indicadorEstado = false;

volatile unsigned long lastPressInc = 0;
volatile unsigned long lastPressDec = 0;

hw_timer_t * timer = NULL;
portMUX_TYPE timerMux = portMUX_INITIALIZER_UNLOCKED;

// Función para mostrar valor en LEDs
void mostrar(int valor, const int * leds) {
  for (int i = 0; i < 4; i++) {
    bool bitestado = bitRead(valor, i);
    digitalWrite(leds[i], bitestado);
  }
}

// ISR para incrementar contador manual (botón)
void IRAM_ATTR incrementar() {
  unsigned long tiempo = millis();
  if (tiempo - lastPressInc > 200) {
    contadorManual++;
    if (contadorManual > 15) contadorManual = 0;
    lastPressInc = tiempo;
  }
}

// ISR para decrementar contador manual (botón)
void IRAM_ATTR decrementar() {
  unsigned long tiempo = millis();
  if (tiempo - lastPressDec > 200) {
    contadorManual--;
    if (contadorManual < 0) contadorManual = 15;
    lastPressDec = tiempo;
  }
}

// ISR del timer (incrementa contador automático cada 250ms)
void IRAM_ATTR onTimer() {
  portENTER_CRITICAL_ISR(&timerMux);
  contadorAutomatico++;
  if (contadorAutomatico > 15) contadorAutomatico = 0;

  // Comparar contadores
  if (contadorAutomatico == contadorManual) {
    indicadorEstado = !indicadorEstado;                // Toggle LED indicador
    digitalWrite(LED_INDICADOR, indicadorEstado ? HIGH : LOW);
    contadorAutomatico = 0;                             // Reiniciar contador automático
  }

  // Actualizar LEDs contador automático
  for (int i = 0; i < 4; i++) {
    digitalWrite(ledsAuto[i], (contadorAutomatico >> i) & 0x01);
  }
  portEXIT_CRITICAL_ISR(&timerMux);
}

void setup() {
  Serial.begin(115200);

  // Configurar LEDs contador manual
  for (int i = 0; i < 4; i++) {
    pinMode(ledsManual[i], OUTPUT);
    digitalWrite(ledsManual[i], LOW);
  }

  // Configurar LEDs contador automático
  for (int i = 0; i < 4; i++) {
    pinMode(ledsAuto[i], OUTPUT);
    digitalWrite(ledsAuto[i], LOW);
  }

  // Configurar LED indicador
  pinMode(LED_INDICADOR, OUTPUT);
  digitalWrite(LED_INDICADOR, LOW);

  // Configurar botones con pull-up interno
  pinMode(botonInc, INPUT_PULLUP);
  pinMode(botonDec, INPUT_PULLUP);

  attachInterrupt(digitalPinToInterrupt(botonInc), incrementar, FALLING);
  attachInterrupt(digitalPinToInterrupt(botonDec), decrementar, FALLING);

  // Configurar timer
  timer = timerBegin(0, 80, true); // 80 prescaler, 1 tick = 1 us
  timerAttachInterrupt(timer, &onTimer, true);
  timerAlarmWrite(timer, 250000, true); // 250 ms
  timerAlarmEnable(timer);
}

void loop() {
  // Mostrar contador manual en LEDs (no se hace en ISR para evitar retrasos)
  mostrar(contadorManual, ledsManual);

  // Puedes agregar aquí debug serial si quieres
  // Serial.print("Manual: "); Serial.print(contadorManual);
  // Serial.print("  Automatico: "); Serial.println(contadorAutomatico);

  delay(50); // Pequeña espera para evitar parpadeos muy rápidos en pantalla serial
}
  */
//**************************************PARTE 3 Y 4***************************************/
#include <Arduino.h>
#include <stdint.h>

// Pines LEDs contador manual
const int ledsManual[4] = {32, 33, 25, 14};
// Pines LEDs contador automático
const int ledsAuto[4] = {12, 13, 21, 22};
// Pin LED indicador
const int LED_INDICADOR = 4;

// Pines botones
const int botonInc = 27;
const int botonDec = 26;

// --- Botón capacitivo (B3) ---
const int pinCap = 15;           // Pin táctil #5 -> GPIO15
int umbralCap = 30;              // Sensibilidad del toque

volatile int contadorManual = 0;
volatile int contadorAutomatico = 0;
volatile bool indicadorEstado = false;

volatile unsigned long lastPressInc = 0;
volatile unsigned long lastPressDec = 0;

hw_timer_t * timer = NULL;
portMUX_TYPE timerMux = portMUX_INITIALIZER_UNLOCKED;

void mostrar(int valor, const int * leds) {
  for (int i = 0; i < 4; i++) {
    bool bitestado = bitRead(valor, i);
    digitalWrite(leds[i], bitestado);
  }
}

void IRAM_ATTR incrementar() {
  unsigned long tiempo = millis();
  if (tiempo - lastPressInc > 200) {
    contadorManual++;
    if (contadorManual > 15) contadorManual = 0;
    lastPressInc = tiempo;
  }
}

void IRAM_ATTR decrementar() {
  unsigned long tiempo = millis();
  if (tiempo - lastPressDec > 200) {
    contadorManual--;
    if (contadorManual < 0) contadorManual = 15;
    lastPressDec = tiempo;
  }
}

// ISR del timer (incrementa contador automático cada 250ms)
void IRAM_ATTR onTimer() {
  portENTER_CRITICAL_ISR(&timerMux);
  contadorAutomatico++;
  if (contadorAutomatico > 15) contadorAutomatico = 0;

  if (contadorAutomatico == contadorManual) {
    indicadorEstado = !indicadorEstado;
    digitalWrite(LED_INDICADOR, indicadorEstado ? HIGH : LOW);
    contadorAutomatico = 0;   // Reiniciar contador automático
  }

  for (int i = 0; i < 4; i++) {
    digitalWrite(ledsAuto[i], (contadorAutomatico >> i) & 0x01);
  }
  portEXIT_CRITICAL_ISR(&timerMux);
}

void setup() {
  Serial.begin(115200);

  for (int i = 0; i < 4; i++) {
    pinMode(ledsManual[i], OUTPUT);
    digitalWrite(ledsManual[i], LOW);
  }
  for (int i = 0; i < 4; i++) {
    pinMode(ledsAuto[i], OUTPUT);
    digitalWrite(ledsAuto[i], LOW);
  }

  pinMode(LED_INDICADOR, OUTPUT);
  digitalWrite(LED_INDICADOR, LOW);

  pinMode(botonInc, INPUT_PULLUP);
  pinMode(botonDec, INPUT_PULLUP);

  attachInterrupt(digitalPinToInterrupt(botonInc), incrementar, FALLING);
  attachInterrupt(digitalPinToInterrupt(botonDec), decrementar, FALLING);

  timer = timerBegin(0, 80, true);
  timerAttachInterrupt(timer, &onTimer, true);
  timerAlarmWrite(timer, 250000, true);
  timerAlarmEnable(timer);

  // --- Sensor capacitivo ---
  touchAttachInterrupt(pinCap, NULL, umbralCap);  // No ISR, sólo ajustar para lectura
}

void loop() {
  mostrar(contadorManual, ledsManual);

  // Leer sensor capacitivo
  int lectura = touchRead(pinCap);
  // Si detecta toque (valor más bajo que umbral), reinicia contador automático
  if (lectura < umbralCap) {
    portENTER_CRITICAL(&timerMux);
    contadorAutomatico = 0;
    portEXIT_CRITICAL(&timerMux);
    Serial.println("B3 TOCADO: contador automático reiniciado");
    delay(300); // anti-rebote táctil
  }

  delay(50);
}


